{"meta":{"title":"Mari's Notes","subtitle":null,"description":null,"author":"Mari","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-06-09T09:59:45.000Z","updated":"2018-06-09T09:59:45.937Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"映像","date":"2018-06-09T09:12:58.143Z","updated":"2018-06-09T09:12:58.143Z","comments":true,"path":"gallery/index.html","permalink":"http://yoursite.com/gallery/index.html","excerpt":"","text":""}],"posts":[{"title":"Globbing","slug":"Globbing","date":"2018-06-10T12:52:19.000Z","updated":"2018-06-10T14:10:15.432Z","comments":true,"path":"2018/06/10/Globbing/","link":"","permalink":"http://yoursite.com/2018/06/10/Globbing/","excerpt":"","text":"Globbing: Matching FilesAny time you want to operate on a bunch of file that have similar names, you an use glob pattern to do it. I am not making up ths name. Globbing is the real,actual,technical term for matching files by name in the Unix shell. Seriously, globbing. If you don’t believe me you can look it up, man glob. Globbing is kind of pattern matching for file names. When you write a glob pattern in a shell command,the shell turns. that pattern into a list of file names that exist to match the pattern. For instance,a star matches any string of characters. You an use a star at the beginning or at the end of a pattern.12$ ls *html$ ls app* Patterns can be all sorts of different lengths. You an use two stars in the same pattern. For instance,here,matching every file whose name contains pp.1$ ls *pp* A star can appear in the middle of a pattern. Matching all the files that start with B and end with png.1$ ls b*png There are other patterns you an use as well.Foe instance,to match files thar end in either CSS or HTML,a list of strings in curly braces will match any of the alternatives.1$ ls app.&#123;css.html&#125; A single queston mark matches any one character. So BEA question mark dot png matches both bean and bear,but it doesn’t match beer or bess.1$ ls bea?.png Two question marks matches two characters,and so on.1$ ls bc??.png List of characters inside square brackets matches an one of the characters inside those brackets,so be and then square brackets A-E-I-O-U R dot png will match bear and beer, but not bean or bes.1$ ls be[aeiou]r.png Something to watch out for is that file name in Linux are always case sensitive, and that applies to globbing too.For instace,if you have files that end in jpg in capitals and files that end in jpg in lower case,you have to specify which one you want.12$ ls *JPG$ ls *jpg If you want both,you could use the curly braces.1$ ls *&#123;JPG,jpg&#125; Quiz Copy all the files in the “www” directory that end in “html” to the “backup” directory. 1cp www/*html backup List all the files that end in “jpg” or “png” in the current directory. 123$ ls *&#123;jpg,png&#125;$ ls *jpg *png$ ls *&#123;jp,pn&#125;g Print “Short names:” followed by all the one-character filenames int current directory. 1$ echo Short names: ?","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"The Linux Filesystem","slug":"The-Linux-Filesystem","permalink":"http://yoursite.com/tags/The-Linux-Filesystem/"}]},{"title":"[Digging]支付宝首页交互三部曲2自定义Behavior","slug":"Digging-支付宝首页交互三部曲2自定义Behavior","date":"2017-09-01T12:52:13.000Z","updated":"2018-06-09T09:12:58.143Z","comments":true,"path":"2017/09/01/Digging-支付宝首页交互三部曲2自定义Behavior/","link":"","permalink":"http://yoursite.com/2017/09/01/Digging-支付宝首页交互三部曲2自定义Behavior/","excerpt":"","text":"前言自己动手实现支付宝首页效果 , 用三篇文章记录并分享给大家。 CoordinatorLayout和Behavior 自定义CoordiantorLayout和Behavior 支付宝首页效果实现 文中 : Col 表示 CoordinatorLayout , ABL 表示AppBarLayout , CTL 表示 CollapsingToolbarLayout , SRL 表示 SwipeRefreshLaout , RV 表示 RecyclerVIew。 第二篇文章主要用经典的CoordinatorLayout、AppBarLayout、RecyclerView的联动场景（CAR场景）来分析一下自定义Behavior需要关注的内容 , 以及如何自定义一个Behavior。同时 , 支付宝首页效果和AppBarLayout的效果有相似之处 , 分析CAR场景 , 也有意于后文实现支付宝首页效果。 这篇文章适合同时阅读源码 , 如果已经读过源码 , 可以直接诶跳到最后总结。 Support中的Behavior基类CAR场景中一共出现了两个Behavior , AppBarLayout.Behavior和AppBarLayout.ScrollingViewBehavior , 前者应用于ABL , 后者应用于RV。这两个Behavior是我们这篇文章要分析的主要的类 , 但是在开始之前 , 我们要看一下它们的基类（职责分隔的很不错）。 ViewOffsetBehavior使用ViewOffsetHelper工具类封装View的偏移量。View类支持对offset进行偏移 , 但是并不会保存偏移量。ViewOffsetHelper对Offset和Top/left进行缓存 , 使用ViewCompat工具类进行偏移处理。 1234private void updateOffsets() &#123; ViewCompat.offsetTopAndBottom(mView, mOffsetTop - (mView.getTop() - mLayoutTop)); ViewCompat.offsetLeftAndRight(mView, mOffsetLeft - (mView.getLeft() - mLayoutLeft));&#125; ViewOffsetBehavior除了封装了对水平和垂直方向偏移的Setter和Getter方法 , 还覆写了onLaoutChild()方法 , 上一篇文章中有提到 , 实现这个方法可以代理CoL对子View的布局。不过ViewOffsetBehavior覆写这个方法的目的主要是创建ViewOffsetHelper , 获取真实偏移量并且将child偏移到正确位置。 说句题话外 , 当我们考虑一个滑动交互时 , 不要把滑动看做一个连续的过程 , 而是要拆分成多个单独的循环过程 , 连续的滑动只不过是单独循环过程在时间上不断重复而已 ； 而滑动的单个循环过程 , 说到底是对View进行偏移处理。当看到一个复杂交互效果的时候 , 要学会拆分 , 一个是刚说的时间上拆分 , 另一个方面就是要能拆分成多个单独效果的合成 , 能做到这一步 , 再加上牢固的基础 , 就没有什么交互效果是做不出来的。 HeaderBehaviorHeaderBehavior封装了经典Touch事件分发逻辑 , 主要是实现了Behavior的onInterceptTouchEvent方法和onTouchEvent方法 , 逻辑其实也很简单 : 判断是否可以滑动 当滑动超过阀值之后 , 标记滑动（mIsBeingDragged）并进行拦截 处理ACTION_MOVE事件 , 调用ViewOffsetBehavior的方法进行偏移 使用VelocityTracker计算滑动速度 在ACTION_UP分之中停止并判断是否应该Fling 实现scroll和fling方法 HeaderBehavior的实现简单且清晰 , 都可以当作经典Touch事件实现活动的范例了 , 有这方面需求的同学不要错过。因为HeaderBehavior的定位很明确 , 实现类似AppBarLayout类似的Header功能 , 所以只处理了纵向滑动。 除了scroll和fling暴露给子类的方法主要是setHeaderTopBoottimOffset , 这个方法一共有两个重载声明 , 可以设置边界值避免滑动越界。 123456789101112131415161718192021222324int setHeaderTopBottomOffset(CoordinatorLayout parent, V header, int newOffset) &#123; return setHeaderTopBottomOffset(parent, header, newOffset, Integer.MIN_VALUE, Integer.MAX_VALUE);&#125;int setHeaderTopBottomOffset(CoordinatorLayout parent, V header, int newOffset, int minOffset, int maxOffset) &#123; final int curOffset = getTopAndBottomOffset(); int consumed = 0; if (minOffset != 0 &amp;&amp; curOffset &gt;= minOffset &amp;&amp; curOffset &lt;= maxOffset) &#123; // If we have some scrolling range, and we&apos;re currently within the min and max // offsets, calculate a new offset newOffset = MathUtils.constrain(newOffset, minOffset, maxOffset); if (curOffset != newOffset) &#123; setTopAndBottomOffset(newOffset); // Update how much dy we have consumed consumed = curOffset - newOffset; &#125; &#125; return consumed;&#125; 这个方法是有返回值的 , 这个返回值在子类中处理嵌套滑动或者再次分发滑动是非常有用。 HeaderScrollingViewBehavior同样继承自ViewOffsetBehavior , HeaderScrollingViewBehavior的职责主要是完成对ScrollingView的布局。 CoL的职责是给子类提供协调滚动的接口 , 并不会具体实现某种效果 , 所有子类需要完成的功能和效果 , 都需要通过统一接口Behavior完成。 在Header+ScrollingView的结构中 , HeaderScrollingViewBehavior就是对ScrollingView的控制。 这两者结合要实现的就是MaterialDesign中经典的可收起Header的效果。 为了让Header可收起 , 视觉上ScrollingView的高度被拉长了 , 但实际上ScrollingView的高度并没有变 , 变的是ScrollingView的位置。ScrollingView的测量和布局就是HeaderScrollingViewBehavior的实现内容。 12345678910final int childLpHeight = child.getLayoutParams().height;if (childLpHeight == ViewGroup.Layout.MATCH_PARENT || childLpHeight == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; // If the menu&apos;s height is set match_parent/wrap_content then measure it // with the maximum visible height // &#123;...&#125; return true; &#125;&#125;return false; onMeasureChild方法中的注释说明了只要child和LayoutParams是MATCH_PARENT或者WRAP_CONTENT , 就设置child的高度为最大可见高度。 这里的最大可见高度包含除了header之外的区域以及header收起时额外空出的区域 , 也就是header的可滚动区域。 12345678int availableHeight = View.MeasureSpec.getSize(parentHeightMeasureSpec);if (availableHeight == 0) &#123; // If the measure spec doesn&apos;t specify a size, use the current height availableHeight = parent.getHeight();&#125;final int height = availableHeight - header.getMeasuredHeight() + getScrollRange(header); onLayout 中将ScrollingView置于header下方。 123456available.set( parent.getPaddingLeft() + lp.leftMargin, header.getBottom() + lp.topMargin, parent.getWidth() - parent.getPaddingRight() - lp.rightMargin, parent.getHeight() + header.getBottom() - parent.getPaddingBottom() - lp.bottomMargin); 注意这里Rect的top值取header.getBottom() + lp.topMargin , 而不是 getPaddingTop() + header.getHeight + lp.topMargin , 这是因为header在onLayout时可能已经包含偏移量 , 不能假定header在初始位置 , 即便可能90%的情况均是如此。 说句题外话 , 项目开发过程中会遇到很多这类情况 , 有多种实现方式都能达到预期效果 , 但并不是所有的实现方案都是完整符合预期逻辑的。比如上面的例子 , ScrollingView的预期位置是header下方 , 而不是父控件中除header高度以外的区域。有的时候 , 需要转换角度看问题 , 体会下这其中的区别。 AppBarLayout.BehaviorAppBarLayout.ScrollingViewBehavior相对简单 , 这里略过。 AppbarLayout.Behavior继承自HeaderBehavior , 在其基础上 , 主要实现了以下功能： 支持在布局文件中定义滚动效果：SCROLL/ECIT_UNTIL_COLLAPSED/ENTER_ALWAYLS/ENTER_ALWAYLS_COLLAPSED/SMAP 实现NestedScrolling回调 滚动效果不是这篇文章的重点 , 我们主要看下NestedScrolling的相关实现。 onStartNestedScroll 判断是否是否为纵向滑动 , 并且AppBarLayout支持折叠并且ScrollingView的大小超出屏幕范围。 12345// Return true if we&apos;re nested scrolling vertically, and we have scrollable children// and the scrolling view is big enough to scrollfinal boolean started = (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0 &amp;&amp; child.hasScrollableChildren() &amp;&amp; parent.getHeight() - directTargetChild.getHeight() &lt;= child.getHeight(); onNestedPreScroll 这个方法回提前于 ScrollingView 消费滑动事件。AppBarLayout 的 scrollFlags , 也就是上面说的滚动效果会影响 onNestedPreScroll 方法的实现。抛开这个影响 , 这个方法中 , 首先确定 AppBarLayout 的可滑动范围 , 然后调用 scroll() 方法（继承自ViewOffsetBehavior）进行滚动 , 并将消费多少传递给 consumed 数组。 onNestedScroll 如果向下滚动时 , 在ScrollingVIew消费完滑动时间之后 , 还有剩余 , 说明 ScrollingView 已经滚动到顶部 , AppBarLayout 开始展开。 onNestedFling 这里并没有进行精确的消费 , 只是当ScrollingView触发flag时 , 对 AppbarLayout 执行动画 , 展开或者收起。下篇文章实现支付宝首页效果时 , 实现了对 fling 的精确消费。 总结自定义Behavior主要关心一下两个方面： 测量和布局 实现滑动效果 其中滑动效果有三种实现方式： 经典Touch事件 NestedScrolling LayoutDependent 一般情况下 , CoL的child , 如果自身不可滚动 , 需要实现NestedScrolling来进行联动 , 或者实现Touch事件回调。如果自身可以滚动 , 通过 onDependentViewChanged 方法来响应其他View的偏移量改变事件。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"NestedScrolling","slug":"NestedScrolling","permalink":"http://yoursite.com/tags/NestedScrolling/"}]},{"title":"[Digging]支付宝首页交互三部曲1CoordinatorLayout和Behavior","slug":"Digging-支付宝首页交互三部曲1CoordinatorLayout和Behavior","date":"2017-08-30T13:34:01.000Z","updated":"2018-06-09T09:12:58.139Z","comments":true,"path":"2017/08/30/Digging-支付宝首页交互三部曲1CoordinatorLayout和Behavior/","link":"","permalink":"http://yoursite.com/2017/08/30/Digging-支付宝首页交互三部曲1CoordinatorLayout和Behavior/","excerpt":"","text":"前言自己动手实现支付宝首页效果 , 用三篇文章记录并分享给大家。 CoordinatorLayout和Behavior 自定义CoordiantorLayout和Behavior 支付宝首页效果实现 文中 : Col 表示 CoordiantorLayout , ABL 表示AppBarLayout , CTL 表示 CollapsingToolbarLayout , SRL 表示 SwipeRefreshLaout , RV 表示 RecyclerVIew。 第一篇文章主要讨论Behavior的结构、CoordianatorLayout的实现以及Coordianator和Behavoir之间的通信。除了Behavior相关的内容 , CoordinarotLayout作为官方实现的一个ViewGroup , 也有一些自定义ViewGroup时可以借鉴的内容 , 这些也穿插在这篇文章中。 Behavior结构使用 CoordinatorLayout 结合 ABL , CTL , SWL/RV 可以方便的实现各种 MaterialDesign ToolBar 效果 , 还有 FloatingActionButton , SnackBar 等控件 , 可以直接使用。 Col的主要功能是为其子View提供 协调滚动 的统一接口 , 让子View可以方便的实现诸如嵌套滚动 , 跟随滚动等效果 , 让界面更加灵动 ; 而这个统一接口 , 就是Behavior。 我们先来看一下 Behavior 提供的方法 , 大致可以分为4组: 布局相关 , 这类方法用来重载child的Mesure、 Layout相关的回调。 1234567public boolean onMeasureChild(CoordinatorLayout parent, V child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed);public boolean onLayoutChild(CoordinatorLayout parent, V child, int layoutDirection);public boolean layoutDependsOn(CoordinatorLayout parent, V child, View dependency);public boolean onDependentViewChanged(CoordinatorLayout parent, V child, View dependency);public void onDependentViewRemoved(CoordinatorLayout parent, V child, View dependency) Touch事件相关 , 这组方法用来拦截和处理Touch事件传递。 123public boolean onInterceptTouchEvent(CoordinatorLayout parent, V child, MotionEvent ev);public boolean onTouchEvent(CoordinatorLayout parent, V child, MotionEvent ev);public boolean blocksInteractionBelow(CoordinatorLayout parent, V child); NestedScrolling相关 , 这组方法用来响应NestedScrolling , 更多的NestedScrolling的讨论可以查看另一篇博客 12345678910111213public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, V child, View directTargetChild, View target, int nestedScrollAxes);public void onNestedScrollAccepted(CoordinatorLayout coordinatorLayout, V child, View directTargetChild, View target, int nestedScrollAxes);public void onStopNestedScroll(CoordinatorLayout coordinatorLayout, V child, View target);public void onNestedScroll(CoordinatorLayout coordinatorLayout, V child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed);public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, V child, View target, int dx, int dy, int[] consumed); public boolean onNestedFling(CoordinatorLayout coordinatorLayout, V child, View target, float velocityX, float velocityY, boolean consumed); public boolean onNestedPreFling(CoordinatorLayout coordinatorLayout, V child, View target, float velocityX, float velocityY) 其他辅助方法 12345678910111213141516// 关联/取消关联LayoutParams的时候回调public void onAttachedToLayoutParams(@NonNull CoordinatorLayout.LayoutParams params);public void onDetachedFromLayoutParams();// 控制Scrim效果 , 只有当getScrimOpaticy返回值不为0时才绘制。public int getScrimColor(CoordinatorLayout parent, V child);public float getScrimOpacity(CoordinatorLayout parent, V child);// 暂时没有发现用到的地方public static void setTag(View child, Object tag);public static Object getTag(View child);public boolean onRequestChildRectangleOnScreen(CoordinatorLayout coordinatorLayout, V child, Rect rectangle, boolean immediate);public void onRestoreInstanceState(CoordinatorLayout parent, V child, Parcelable state);public Parcelable onSaveInstanceState(CoordinatorLayout parent, V child);// 防止Col子View间出现遮挡 , 获取child应避免遮挡部分的Rect。public boolean getInsetDodgeRect(@NonNull CoordinatorLayout parent, @NonNull V child, @NonNull Rect rect); 多数情况下我们只需要关注前三组方法。通过这些方法我们看到Behavior可以做的事情不仅仅是 “依赖某个View的变化并且在其变化后进行相应” 这么单一 , Behavior实际上可以控制child在Col中的mesure , layout以及拦截touch事件 , 支持NestedScrolling等等 , 基本上是除了Draw之外的全部自定义VIew需要关注的内容了。 Behavior的使用和自定义我们下一篇文章进行讨论 , 这篇文章我们继续关注Col如何操作Behavior。 设置Behavior给View设置Behavior有两种方法 : 在布局文件中指定 ; 使用`@CoordinatorLayout.DefaultBehavior`注解。 第一种方法适用于多种情况 , 需要注意的是 , 如果使用自定义Behavior , 需要覆写２个参数的构造方法 ; 1public Behavior(Context context, AttributeSet attrs); 因为Col在解析时是通过反射调用Behavior的这个构造方法创建Behavior对象的 : 1234567891011121314151617181920212223242526272829303132333435363738static Behavior parseBehavior(Context context, AttributeSet attrs, String name) &#123; if (TextUtils.isEmpty(name)) &#123; return null; &#125; final String fullName; if (name.startsWith(&quot;.&quot;)) &#123; // Relative to the app package. Prepend the app package name. fullName = context.getPackageName() + name; &#125; else if (name.indexOf(&apos;.&apos;) &gt;= 0) &#123; // Fully qualified package name. fullName = name; &#125; else &#123; // Assume stock behavior in this package (if we have one) fullName = !TextUtils.isEmpty(WIDGET_PACKAGE_NAME) ? (WIDGET_PACKAGE_NAME + &apos;.&apos; + name) : name; &#125; try &#123; Map&lt;String, Constructor&lt;Behavior&gt;&gt; constructors = sConstructors.get(); if (constructors == null) &#123; constructors = new HashMap&lt;&gt;(); sConstructors.set(constructors); &#125; Constructor&lt;Behavior&gt; c = constructors.get(fullName); if (c == null) &#123; final Class&lt;Behavior&gt; clazz = (Class&lt;Behavior&gt;) Class.forName(fullName, true, context.getClassLoader()); c = clazz.getConstructor(CONSTRUCTOR_PARAMS); c.setAccessible(true); constructors.put(fullName, c); &#125; return c.newInstance(context, attrs); &#125; catch (Exception e) &#123; throw new RuntimeException(&quot;Could not inflate Behavior subclass &quot; + fullName, e); &#125; &#125; 第二种方法 , 适用于自定义View并且自定义Behavior的情况 , 比如AppBarLayout : 1234@CoordinatorLayout.DefaultBehavior(AppBarLayout.Behavior.class)public class AppBarLayout extends LinearLayout &#123; // &#123;...&#125;&#125; 如果在布局文件中不另外指定 , 这里将调用Behavior的无参构造方法创建对象。 事件分发上面看到的Behavior的各个方法 , 其调用者基本都是CoL。CoL在自己的回调方法中通过子View Behavior的相关方法 , 将事件向下分发。 在讨论分发方法之前 , 有一点需要注意 : Behavior随人影响的是子View的布局和行为 , 但实际是对CoL本身事件处理的代理。 基本的模式大家可以想到 , 就是遍历子View , 获取Bahavior , 然后调用子Bahavior对应的方法。这里对几个有意思的地方进行讨论 : Touch事件分发Touch事件分发分两个方法onInterceptTouchEvent和onTouchEvent。 CoL的视线中 , 这两个方法都调用performIntercept方法将是否拦截事件的判断交给Behavior处理。每个CoordinatorLayout的子View都有机会拦截事件并响应 , 注意这里子View并不是在自己的onTouch相关方法中进行处理, 而是Behavior子类 , 有机会代理CoL对事件进行拦截并处理。 处于篇幅考虑这里不贴源码了 , 关键的地方这里解释一下 : 在遍历子View之前 , 使用getTopSortedChildren(topmostChildList);获取按照显示顺序自上至下排效果的子View列表。 ViewGroup可以复写getChildDrawingOrder自定义子View的绘制顺序 , getTopSortedChildren方法会按照绘制顺序获取子View ; 在5.0以上版本中 , 还要考虑Z轴次序 , 也就是elevation , 会再进行一次排序 , 最终得到真实可靠的自顶之下的子View分发顺序。这对让子View合理响应Touch事件很重要 , 如果自定义ViewGroup需要有类似功能 , 可以参考CoL的实现。 Behavior通过覆写onInterceptTouch或者onTouchEvent并返回true来声明拦截事件 , Col会将该View缓存到mBehaviorTouchView属性 , 后续事件将直接分发到该View。直到该View的onTouchEvent方法返回false。 在确定mBehaviorTouchView之后 , CoL会将该View（Z轴）下面View的事件流终止 , 具体操作是向这些View分发一个CANCEL事件。 Behavior可以通过覆写blocksInteractionBelow方法block下方View的事件。 在自己不需要处理事件但同时不希望子View处理事件时 , 可以简单的覆写这个方法。 默认实现逻辑是判断getScrimOpaticy的值&gt;0 NestedScrollingNestedScrolling是Behavior实现滑动的重要支撑。前文提到Behavior是对CoL自身事件的代理 , 所以Behavior对NestedScrolling的支持 , 就是在代理CoL的NestedScrollingParent接口的方法。 更多NestedScrolling相关信息参见更早的博客 : Android Nested Scrolling 需要注意的是关于NestedScrolling机制中”消费量”的处理 12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic void onNestedPreScroll(View target, int dx, int dy, int[] consumed) &#123; int xConsumed = 0; int yConsumed = 0; boolean accepted = false; final int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View view = getChildAt(i); if (view.getVisibility() == GONE) &#123; // If the child is GONE, skip... continue; &#125; final LayoutParams lp = (LayoutParams) view.getLayoutParams(); if (!lp.isNestedScrollAccepted()) &#123; continue; &#125; final Behavior viewBehavior = lp.getBehavior(); if (viewBehavior != null) &#123; mTempIntPair[0] = mTempIntPair[1] = 0; viewBehavior.onNestedPreScroll(this, view, target, dx, dy, mTempIntPair); xConsumed = dx &gt; 0 ? Math.max(xConsumed, mTempIntPair[0]) : Math.min(xConsumed, mTempIntPair[0]); yConsumed = dy &gt; 0 ? Math.max(yConsumed, mTempIntPair[1]) : Math.min(yConsumed, mTempIntPair[1]); accepted = true; &#125; &#125; consumed[0] = xConsumed; consumed[1] = yConsumed; if (accepted) &#123; onChildViewsChanged(EVENT_NESTED_SCROLL); &#125;&#125; 注意这里是取了所有Behavior消费掉偏移量的最大值。因为Behavior是代理的角色 , 而各个代理的消费对于NestedScrolling机制来说 , 都会被看作是CoL这个NestedScrollingParent的消费。各Behavior之间是同级的 , 所以他们对事件的消费是”重叠”的（可以重复消费） , 所以这里返回的consumed是取最大值。 LayoutDependence这里是其他博客讲的比较多的地方 , 确定View依赖的dependency变化之后 , 会将变化广播给所有依赖这个View的兄弟View。这里我要说的有两点 : 1.onDependentViewChanged回调的时机。2.依赖关系的存贮。 onDependentViewChanged在某个View的大小或者位置发生变化的时候都会进行回调。并且真正变化之后才会回调。 子View之间的依赖关系通过非循环有向图数据结构进行存储。具体到数据结构上就是通过一个Map&lt;Node, List&lt;Node&gt;&gt;存储（这个Map并不是JDK的实现 , 感兴趣的可以看下源码）。 既然存在依赖关系 , 那么在涉及到对子View遍历的时候 , 就要考虑到子View之间的依赖关系。CoL的实现中prepareChildren方法构建依赖图并根据依赖图进行DFS搜索得到依赖链列表 , 这个列表用在了分发布局、 NestedScrolling、 LayoutDependentChanged的过程中。 自定义LayoutParams自定义ViewGroup很常见 , 但是多数情况下用不到自定义LayoutParams。LayoutParams正如其名 , 用了设置布局参数 , 也就是控制ViewGroup如何 mesure 和 layout 子View。 如果一个自定义ViewGroup提供了额外的布局参数 , 那就需要自定义LayoutParams了。自定义LayoutParams并没有多复杂 , 这里列出几点需要注意的地方。 基类如果自定义LayoutParams需要支持margin , 继承自 ViewGroup.MarginLayoutParams即可 , 默认的ViewGroup.LayoutParams并不支持margin。 构造方法LayoutParams默认有多个不同参数的构造方法 : LayoutParams(Context context, AttrbuteSet attr) 使用于解析布局文件时生成LayoutParams , layout相关的xml属性 , 就是在这个构造方法里面解析的 LayoutParams(int width, int height) 代码构建时只传入宽高 LayoutParams(LayoutParams source) LayoutParams转换 LayoutParams() 无参构造函数 自定义LayoutParams也要覆写这些构造方法并做相应的转换。 ViewGroup方法使用自定义 LayoutParams 的 ViewGroup , 也需要实现几个相关方法 , 主要是在解析 、 addView 的时候生成适合的 LayoutParams。 12345protected LayoutParams generateDefaultLayoutParams();protected LayoutParams generateLayoutParams(ViewGroup.LayoutParams p);public LayoutParams generateLayoutParams(AttributeSet attrs);// 检查LayoutParams是否自定义的LayoutParams类型protected boolean checkLayoutParams(ViewGroup.LayoutParams p); 具体可以参考 CoL。 CoordinatorLayout.LayoutParamsCoL.LP 主要实现了基于 anchorView 的布局和 keylines（纵向基准线 , 子View可以对齐到keylines）的布局、 保存Bahavior、 存储滑动过程中的标记位 , 具体实现这里就不展开了 , 逻辑比较简单。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"NestedScrolling","slug":"NestedScrolling","permalink":"http://yoursite.com/tags/NestedScrolling/"}]},{"title":"Android Nested Scrolling","slug":"Android-Nested-Scrolling","date":"2017-08-27T11:34:18.000Z","updated":"2018-06-09T09:12:58.139Z","comments":true,"path":"2017/08/27/Android-Nested-Scrolling/","link":"","permalink":"http://yoursite.com/2017/08/27/Android-Nested-Scrolling/","excerpt":"","text":"Android常规的Touch事件机制是自顶向下 , 由外向内的, 一旦确定了时间消费者View , 随后的时间都将传递到该View。 因为是自顶向下 , 父控件可以随时拦截事件 , 下拉刷新、拖拽排序、折叠等交互效果都可以通过这套机制完成。Touch事件传递机制是Android开发必须掌握的基本内容。但是这套机制存在一个缺陷: 子View 无法通知父View处理事件 NestedScrolling就是为了这个场景设计的。 NestedScrollingChild和NestedScrollingParentNestedScrolling是指存在嵌套滑动的场景 , 常见用于下拉刷新、展开/收起标题栏等。Support包中的CoordinatorLayout和ScrollRefreshLayout就是基于NestedScrolling机制实现的。 NestedScrollingChild和NestedScrollParent分别定义了嵌套子View和嵌套父View需要实现的接口,方法列表分别如下 , 可以先略过 , 后面会把这些方法串起来。另外这些方法基本都是通过NestedScrollChildHelper和NestedScrollParentHelper来实现的 , 一般并不需要手动编写多少逻辑。 1234567891011// NestedScrollingChildvoid setNestedScrollingEnabled(boolean enabled);boolean isNestedScrollingEnabled();boolean startNestedScroll(int axes);void stopNestedScroll();boolean hasNestedScrollingParent();boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow);boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow);boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed);boolean dispatchNestedPreFling(float velocityX, float velocityY); 12345678910// NestedScrollingParentboolean onStartNestedScroll(View child, View target, int nestedScrollAxes);void onNestedScrollAccepted(View child, View target, int nestedScrollAxes);void onStopNestedScroll(View target);void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed);void onNestedPreScroll(View target, int dx, int dy, int[] consumed);boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed);boolean onNestedPreFling(View target, float velocityX, float velocityY);int getNestedScrollAxes(); 通过方法名可以看出,NestedScrollingChild的方法均为主动方法 , 而NestedScrollingParent的方法基本都是回调方法。这也是NestedScrolling机制的一个体现 , 子View作为NestedScrolling事件传递的主动方。 NestedScrolling机制生效的前提条件是子View作为Touch事件的消费者 , 在消费过程中向父View发送NestedScrolling事件（注意这里不是Touch事件 , 而是NestedScrolling事件）。 NestedScrolling事件传递NestedScrolling机制中 , NestedScrolling事件使用dx,dy表示 , 分别表示子View Touch 事件处理方法中判定的x和y方向上的滚动偏移量。 NestedScrolling事件的传递： 由子View产生NestedScrolling事件 ; 发送给父View进行处理 , 父View处理之后 , 返回消费的偏移量 ; 子View根据View消费的偏移量计算NestedScrolling事件剩余偏移量 ; 根据剩余偏移量判断是否能处理滚动事件 ; 如果处理事件 , 同时将自身滚动情况通知父View ; 处理完成 , 事件传递完成。 这里只说明了一层嵌套的情况 , 事实上NestedScrolling很可能出现在多重嵌套的场景。对于多重嵌套 , 步骤 2、3、4将事件自底向上进行传递 , 步骤2中消费的偏移量将记录所有嵌套父View消费偏移量的总和。这里不再重复。 Fling事件的传递和Scroll类似 , 也不再赘述。 方法调用流程我们可以上面的方法根据NestedScrolling事件传递的不同阶段进行分组（Fling跟随Scrolling发生）。 初始阶段： 确认开启NestedScrolling , 关联父View和子View。 123// NestedScrollingChildvoid setNestedScrollingEnabled(boolean enabled);boolean startNestedScroll(int axes); 1234// NestedScrollingParentint getNestedScrollAxes();boolean onStartNestedScroll(View child, View target, int nestedScrollAxes);void onNestedScrollAccepted(View child, View target, int nestedScrollAxes); 预滚动阶段： 子View将事件分发到父View 12// NestedScrollingChildboolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow); 12// NestedScrollingParentvoid onNestedPreScroll(View target, int dx, int dy, int[] consumed); 滚动阶段： 子View处理滚动事件 123// NestedScrollingChildboolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow); 123// NestedScrollingParentvoid onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed); 结束阶段： 结束 12// NestedScrollingChildvoid stopNestedScroll(); 12// NestedScrollingParentvoid onStopNestedScroll(View target); 下面是一次嵌套滚动（三级嵌套）从开始到结束的方法调用时序图： 金色是NestedScrollingChild的方法 , 为View主动调用。 紫色是NestedScrollingParent回调的方法 , 由View的相关方法调用。 橙色是滚动事件被消费的时机 划重点最重要的一点：pre-scroll过程是子View向父View传递事件 , 而scroll过程才是子View消耗滚动事件的过程 , 也就是说父View拥有优先消费事件的权利。 从事件消耗的优先级来看 , 可以画这样一张图。 dispatchNestedPreScroll传给父View的是没有被消费的滚动事件 , 父View消费完之后通过consumed数组返回 , 如果还有剩余 , 由子View进行消费 , 并将消费多少和剩余多少再次发给父View。 如果一个View同时作为NestedScrollChild和NestedScrollParent , 那么在处理 onNestedPreScrolling和onNestedScrolling的时候也要按照自底向上的规则 , 先让父View处理事件。 实例分析以及Q&amp;A这里通过对CoordinatorLayout -&gt; SwipeRefreshLaout -&gt; RecyclerView这个常用的三级嵌套实例进行分析 , 以便深入理解NestedScrolling事件传递的机制。 嗯 , 其实上面那张时序图基本就通过方法调用顺序 , 理清了传递过程。 这里通过几个Q&amp;A , 来答疑解惑。 如果你还不清楚SwipeRefreshLaout的原理 , 建议先去看一下我的另外一篇文章：SwipeRefreshLaout源码解析CL代表CoordinatorLayout , SRL 代表SwipeRefreshLaout , RV 表示RecyclerView Q1：SwipeRefreshLaout在Touch事件分发过程中 , 为什么SwipeRefreshLaout没有作为Touch事件的消费者? A1：Touch事件流从ACTION_DOWN开始： 先经过SRL的onInterceptTouchEvent() , 返回false 进入RV的onInterceptTouchEvent() , 进入ACTION_DOWN分支 , RV调用startNestedScroll()方法 根据上面的时序图 , 会调用SRL的onNestedScrollAccepted() , 而这个方法里面 , 会将SRL的mNestedScrollInProgress设置为true。实际上到此为止已经进入了NestedScrolling事件的分发流程。 后续事件 , SRL的onInterceptTouchEvent()反复会根据mNestedScrollInProgress属性返回false , 也就不会拦截事件了。 CL的部分根据时序图可以清楚理解。 Q2：接Q1 , 既然没有拦截 , 为什么还能处理事件？ A2：首先 , 要注意SRL主力的不是Touch事件 , 而是NestedScrolling事件 , 还记得吗 , 实际上是以(dx,dy)偏移量的形式存在的。A1中可以看到 , 一旦触发NestedScrolling机制 , 作为父View的SRL , 就有优先处理NestedScrolling事件的权利 , 所以当然能处理事件（当然优先级比CL低 , 所以只能处理CL处理剩下的部分）。 Q3：为什么CL能消费事件进行滚动? A3：NestedScrolling机制决定NestedScrolling事件是自底向上传播的 , 并且通过pre-scroll和scoll两个过程划分 , 越上层的View , 处理NestedScrolling事件的优先级越高 , CL在最上层 , 自然优先处理事件。 Q4：对于SwipeRefreshLaout来说 , 什么时候通过TouchEvent处理事件 , 什么时候通过NestedScrolling机制处理事件? A4：NestedScrolling机制由实现了NestedScrollingChild接口的子View触发 , 所以事实上 , 当SRL的子View实现了NestedScrollingChild接口时 , 均会使用NestedScrolling机制分发事件给SRL。比如RecyclerView作为子View将通过NestedScrolling处理事件 , 如果是ListView作为子View , 将通过Touch机制处理事件。 总结读到这里你会发现 , 要理解NestedScrolling , 实际上就是要理解NestedScrolling事件分发过程。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"NestedScrolling","slug":"NestedScrolling","permalink":"http://yoursite.com/tags/NestedScrolling/"}]},{"title":"轻量级自定义圆角ImageView-适配-Android-L","slug":"轻量级自定义圆角ImageView-适配-Android-L","date":"2017-07-25T14:46:42.000Z","updated":"2018-06-09T09:12:58.143Z","comments":true,"path":"2017/07/25/轻量级自定义圆角ImageView-适配-Android-L/","link":"","permalink":"http://yoursite.com/2017/07/25/轻量级自定义圆角ImageView-适配-Android-L/","excerpt":"","text":"最近在看Google的一个开源项目 Topeka ,想研究一下,了解大神都怎么写代码的.官方介绍只有一句话：一部有趣的问答应用！传送门 在app的登录页面有一个头像选择,实现了圆形头像,选择头像时ImageView外圈增加一个圆圈,而且适配了5.0以上的版本.实现也很优雅.于是我就仿照写了一个圆角的 ImageView. 效果如下：屏幕中间的就是自定义的 圆角ImageView 布局文件如下: 使用方法也很简单,在布局文件中使用就可以了:12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;com.sync.customviewstudy.view.RoundImageView android:layout_width=&quot;80dp&quot; android:layout_height=&quot;80dp&quot; android:layout_centerInParent=&quot;true&quot; android:id=&quot;@+id/img&quot; android:src=&quot;@mipmap/avatar_12_raster&quot; /&gt;&lt;/RelativeLayout&gt; 先上自定义ImageVIew的代码: AvatarView.java12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Description: 圆形头像 * Author：Mari on 2017-07-25 22:30 * Contact：289168296@qq.com */public class RoundImageView extends ImageView &#123; public RoundImageView(Context context) &#123; super(context); &#125; public RoundImageView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public RoundImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public void setImageDrawable(@Nullable Drawable drawable) &#123; if (ApiLevelHelper.isAtLeast(Build.VERSION_CODES.LOLLIPOP)) &#123; setClipToOutline(true); super.setImageDrawable(drawable); &#125; else &#123; BitmapDrawable bitmapDrawable = (BitmapDrawable) drawable; RoundedBitmapDrawable roundedDrawable = RoundedBitmapDrawableFactory.create(getResources(), bitmapDrawable.getBitmap()); roundedDrawable.setCircular(true); super.setImageDrawable(roundedDrawable); &#125; &#125; // onLayout() 之后调用 @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (ApiLevelHelper.isLowerThan(Build.VERSION_CODES.LOLLIPOP)) &#123; return; &#125; if (w &gt; 0 &amp;&amp; h &gt; 0) &#123; setOutlineProvider(new RoundOutlineProvider(Math.min(w, h))); &#125; &#125;&#125; 代码很少,在 setImageDrawable,onSizeChanged 两个方法中区分 Android 5.0 即以上版本和5.0一下2个版本不同的处理方式, 5.0 以下版本使用 RoundedBitmapDrawable 实现圆形 drawable 资源,而在 5.0 以上版本使用 RoundOutlineProvider 实现圆角 drawable 资源. ‘RoundOutlineProvider’ 继承 ViewOutlineProvider 这个类是在 android.view.ViewOutlineProvider 包下面,大家想要了解更多可以自己去找下资料看看哈. RoundOutlineProvider.java 1234567891011121314151617/** * Description: Creates round outlines for views. * Author：Mari on 2017-07-25 22:30 * Contact：289168296@qq.com */@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public class RoundOutlineProvider extends ViewOutlineProvider &#123; private final int mSize; public RoundOutlineProvider(int size) &#123; mSize = size; &#125; @Override public void getOutline(View view, Outline outline) &#123; outline.setOval(0, 0, mSize, mSize); &#125;&#125; ApiLevelHelper.java 12345678910111213141516171819202122232425262728293031/** * Encapsulates checking api levels. */public class ApiLevelHelper &#123; private ApiLevelHelper() &#123; //no instance &#125; /** * Checks if the current api level is at least the provided value. * * @param apiLevel One of the values within &#123;@link Build.VERSION_CODES&#125;. * @return &lt;code&gt;true&lt;/code&gt; if the calling version is at least &lt;code&gt;apiLevel&lt;/code&gt;. * Else &lt;code&gt;false&lt;/code&gt; is returned. */ public static boolean isAtLeast(int apiLevel) &#123; return Build.VERSION.SDK_INT &gt;= apiLevel; &#125; /** * Checks if the current api level is at lower than the provided value. * * @param apiLevel One of the values within &#123;@link Build.VERSION_CODES&#125;. * @return &lt;code&gt;true&lt;/code&gt; if the calling version is lower than &lt;code&gt;apiLevel&lt;/code&gt;. * Else &lt;code&gt;false&lt;/code&gt; is returned. */ public static boolean isLowerThan(int apiLevel) &#123; return Build.VERSION.SDK_INT &lt; apiLevel; &#125;&#125; 源代码地址: https://github.com/MariShunxiang/AndroidSamples/blob/master/widget/customviewstudy/src/main/java/com/sync/customviewstudy/view/RoundOutlineProvider.java","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"Atom 编写 markdown 上传图片","slug":"Atom-编写-markdown-上传图片","date":"2017-07-23T07:34:13.000Z","updated":"2018-06-09T09:12:58.139Z","comments":true,"path":"2017/07/23/Atom-编写-markdown-上传图片/","link":"","permalink":"http://yoursite.com/2017/07/23/Atom-编写-markdown-上传图片/","excerpt":"","text":"因为对markdown比较感兴趣,平时的文档编写都是用markdown来完成.以前是用csdn的博客编辑器,支持图片上传,预览. 最近在公司的文档也开始用markdown来写了,就会遇到一个问题：如何上传图片？ 最开始我不知道图床啥的,就是自己先把图片上传到 github ,然后再手动引用连接到文章中,这样的也能实现markdown的图片引用. 但是不够优雅,而且很麻烦.上传一张图片有4到5步操作. 然后发现了 Atom编辑器的两个插件,使用 7牛 作为图床可以实现： qq截图,然后直接在 Atom 的编辑页面 ctrl+v 粘贴, 弹出上传图片提示，会让你填写一个 title ，点击enter会自动构建一条markdown图片语句。这样上传图片就完成了. 效果如下： 这个就是我一键上传的图片,是不是很简单! 下面我就给大家介绍实现的方法: 第一步, 注册7牛云7牛云的注册,新建空间就不过多介绍了. 吴同学博客: 使用七牛作为github博客的图床 佚名大神博客: 如何使用七牛 相信大家可以搞定的. 第二步, 下载 markdown-assistant,qiniu-uploader 插件 安装好插件后还需要对它们进行设置: 设置markdown-assistant的时候发现，会让你填一个上传插件，而且默认已经帮你填好了qiniu-uploader，其实你也就什么都不用设置了。 如下图: 设置qiniu-uploader，主要设置四个参数： qiniu-uploader 使用报错解决方法我自己在使用 qiniu-uploader 时Atom提示错误,如下图: 可能你们也会遇到这个问题,解决方案地址 这里我整理了一下步骤: 先找到 Atom 的配置文件,再找到插件的安装路径. 我的电脑是Windows系统,路径是是这样的 : C:\\Users\\Administrator\\.atom\\packages\\qiniu-uploader\\node_modules\\qiniu\\qiniu 替换 \\qiniu 文件夹下面的三个 .js 文件: io.js,rpc.js,zone.js, 然后就ok了 为了方便大家更换这三个文件,我就贴出来了: os.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128var conf = require(&apos;./conf&apos;);var util = require(&apos;./util&apos;);var rpc = require(&apos;./rpc&apos;);var fs = require(&apos;fs&apos;);var getCrc32 = require(&apos;crc32&apos;);var url = require(&apos;url&apos;);var mime = require(&apos;mime&apos;);var Readable = require(&apos;stream&apos;).Readable;var formstream = require(&apos;formstream&apos;);var urllib = require(&apos;urllib&apos;);var zone = require(&apos;./zone&apos;);exports.UNDEFINED_KEY = &apos;?&apos;exports.PutExtra = PutExtra;exports.PutRet = PutRet;exports.put = put;exports.putWithoutKey = putWithoutKey;exports.putFile = putFile;exports.putReadable = putReadable;exports.putFileWithoutKey = putFileWithoutKey;// @gist PutExtrafunction PutExtra(params, mimeType, crc32, checkCrc) &#123; this.params = params || &#123;&#125;; this.mimeType = mimeType || null; this.crc32 = crc32 || null; this.checkCrc = checkCrc || 0;&#125;// @endgistfunction PutRet(hash, key) &#123; this.hash = hash || null; this.key = key || null;&#125;// onret: callback function instead of retfunction putReadable (uptoken, key, rs, extra, onret) &#123; if (!extra) &#123; extra = new PutExtra(); &#125; if (!extra.mimeType) &#123; extra.mimeType = &apos;application/octet-stream&apos;; &#125; if (!key) &#123; key = exports.UNDEFINED_KEY; &#125; rs.on(&quot;error&quot;, function (err) &#123; onret(&#123;code: -1, error: err.toString()&#125;, &#123;&#125;); &#125;); // 设置上传域名 // zone.up_host(uptoken, conf); zone.up_host_async(uptoken, conf, function() &#123; var form = getMultipart(uptoken, key, rs, extra); return rpc.postMultipart(conf.UP_HOST, form, onret); &#125;);&#125;function put(uptoken, key, body, extra, onret) &#123; var rs = new Readable(); rs.push(body); rs.push(null); if (!extra) &#123; extra = new PutExtra(); &#125; if (extra.checkCrc == 1) &#123; var bodyCrc32 = getCrc32(body); extra.crc32 = &apos;&apos; + parseInt(bodyCrc32, 16); &#125; else if (extra.checkCrc == 2 &amp;&amp; extra.crc32) &#123; extra.crc32 = &apos;&apos; + extra.crc32 &#125; return putReadable(uptoken, key, rs, extra, onret)&#125;function putWithoutKey(uptoken, body, extra, onret) &#123; return put(uptoken, null, body, extra, onret);&#125;function getMultipart(uptoken, key, rs, extra) &#123; var form = formstream(); form.field(&apos;token&apos;, uptoken); if (key != exports.UNDEFINED_KEY) &#123; form.field(&apos;key&apos;, key); &#125; form.stream(&apos;file&apos;, rs, key, extra.mimeType); if (extra.crc32) &#123; form.field(&apos;crc32&apos;, extra.crc32); &#125; for (var k in extra.params) &#123; form.field(k, extra.params[k]); &#125; return form;&#125;function putFile(uptoken, key, loadFile, extra, onret) &#123; var rs = fs.createReadStream(loadFile); if (!extra) &#123; extra = new PutExtra(); &#125; if (extra.checkCrc == 1) &#123; var fileCrc32 = getCrc32(fs.readFileSync(loadFile)); extra.crc32 = &apos;&apos; + parseInt(fileCrc32, 16); &#125; else if (extra.checkCrc == 2 &amp;&amp; extra.crc32) &#123; extra.crc32 = &apos;&apos; + extra.crc32 &#125; if (!extra.mimeType) &#123; extra.mimeType = mime.lookup(loadFile); &#125; return putReadable(uptoken, key, rs, extra, onret);&#125;function putFileWithoutKey(uptoken, loadFile, extra, onret) &#123; return putFile(uptoken, null, loadFile, extra, onret);&#125; rpc.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var urllib = require(&apos;urllib&apos;);var util = require(&apos;./util&apos;);var conf = require(&apos;./conf&apos;);exports.postMultipart = postMultipart;exports.postWithForm = postWithForm;exports.postWithoutForm = postWithoutForm;function postMultipart(uri, form, onret) &#123; return post(uri, form, form.headers(), onret);&#125;function postWithForm(uri, form, token, onret) &#123; var headers = &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125;; if (token) &#123; headers[&apos;Authorization&apos;] = token; &#125; return post(uri, form, headers, onret);&#125;function postWithoutForm(uri, token, onret) &#123; var headers = &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &#125;; if (token) &#123; headers[&apos;Authorization&apos;] = token; &#125; return post(uri, null, headers, onret);&#125;function post(uri, form, headers, onresp) &#123; headers = headers || &#123;&#125;; headers[&apos;User-Agent&apos;] = headers[&apos;User-Agent&apos;] || conf.USER_AGENT; var data = &#123; headers: headers, method: &apos;POST&apos;, dataType: &apos;json&apos;, timeout: conf.RPC_TIMEOUT, &#125;; if (Buffer.isBuffer(form) || typeof form === &apos;string&apos;) &#123; data.content = form; &#125; else if (form) &#123; data.stream = form; &#125; else &#123; data.headers[&apos;Content-Length&apos;] = 0; &#125;; var req = urllib.request(uri, data, function(err, result, res) &#123; var rerr = null; if (err || Math.floor(res.statusCode/100) !== 2) &#123; rerr = &#123;code: res&amp;&amp;res.statusCode||-1, error: err||result&amp;&amp;result.error||&apos;&apos;&#125;; &#125; onresp(rerr, result, res); &#125;); return req;&#125; zone.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// var request = require(&apos;urllib-sync&apos;).request;var urllib = require(&apos;urllib&apos;);var util = require(&apos;./util&apos;);//conf 为全局变量exports.up_host = function (uptoken, conf)&#123; var version = process.versions; var num = version.node.split(&quot;.&quot;)[0]; // node 版本号低于 1.0.0, 使用默认域名上传，可以在conf中指定上传域名 if(num &lt; 1 )&#123; conf.AUTOZONE = false; &#125; if(!conf.AUTOZONE)&#123; return; &#125; var ak = uptoken.toString().split(&quot;:&quot;)[0]; var tokenPolicy = uptoken.toString().split(&quot;:&quot;)[2]; var tokenPolicyStr = new Buffer(tokenPolicy, &apos;base64&apos;).toString(); var json_tokenPolicyStr = JSON.parse(tokenPolicyStr); var scope = json_tokenPolicyStr.scope; var bucket = scope.toString().split(&quot;:&quot;)[0]; // bucket 相同，上传域名仍在过期时间内 if((new Date().getTime() &lt; conf.EXPIRE) &amp;&amp; bucket == conf.BUCKET)&#123; return; &#125; //记录bucket名 conf.BUCKET = bucket; var request_url = &apos;http://uc.qbox.me/v1/query?ak=&apos;+ ak + &apos;&amp;bucket=&apos; + bucket; var res = request(&apos;http://uc.qbox.me/v1/query?ak=&apos;+ ak + &apos;&amp;bucket=&apos; + bucket, &#123; &apos;headers&apos;: &#123; &apos;Content-Type&apos;: &apos;application/json&apos; &#125; &#125;); if(res.statusCode == 200)&#123; var json_str = JSON.parse(res.body.toString()); //判断设置使用的协议, 默认使用http if(conf.SCHEME == &apos;http&apos;)&#123; conf.UP_HOST = json_str.http.up[1]; &#125;else&#123; conf.UP_HOST = json_str.https.up[0]; &#125; conf.EXPIRE = 86400 + new Date().getTime(); &#125;else&#123; var err = new Error(&apos;Server responded with status code &apos; + res.statusCode + &apos;:\\n&apos; + res.body.toString()); err.statusCode = res.statusCode; err.headers = res.headers; err.body = res.body; throw err; &#125;&#125;exports.up_host_async = function (uptoken, conf, callback)&#123; var version = process.versions; var num = version.node.split(&quot;.&quot;)[0]; // node 版本号低于 1.0.0, 使用默认域名上传，可以在conf中指定上传域名 if(num &lt; 1 )&#123; conf.AUTOZONE = false; &#125; if(!conf.AUTOZONE)&#123; callback(); return; &#125; var ak = uptoken.toString().split(&quot;:&quot;)[0]; var tokenPolicy = uptoken.toString().split(&quot;:&quot;)[2]; var tokenPolicyStr = new Buffer(tokenPolicy, &apos;base64&apos;).toString(); var json_tokenPolicyStr = JSON.parse(tokenPolicyStr); var scope = json_tokenPolicyStr.scope; var bucket = scope.toString().split(&quot;:&quot;)[0]; // bucket 相同，上传域名仍在过期时间内 if((new Date().getTime() &lt; conf.EXPIRE) &amp;&amp; bucket == conf.BUCKET)&#123; callback(); return; &#125; //记录bucket名 conf.BUCKET = bucket; var request_url = &apos;http://uc.qbox.me/v1/query?ak=&apos;+ ak + &apos;&amp;bucket=&apos; + bucket; var data = &#123; contentType: &apos;application/json&apos;, method: &apos;GET&apos;, &#125;; var req = urllib.request(request_url, data, function(err, result, res) &#123; // console.log(result); if(res.statusCode == 200)&#123; // console.log(result); var json_str = JSON.parse(result.toString()); // console.log(json_str); //判断设置使用的协议, 默认使用http if(conf.SCHEME == &apos;http&apos;)&#123; conf.UP_HOST = json_str.http.up[1]; &#125;else&#123; conf.UP_HOST = json_str.https.up[0]; &#125; conf.EXPIRE = 86400 + new Date().getTime(); callback(); return; &#125;else&#123; var err = new Error(&apos;Server responded with status code &apos; + res.statusCode + &apos;:\\n&apos; + res.body.toString()); err.statusCode = res.statusCode; err.headers = res.headers; err.body = res.body; throw err; callback(); &#125; &#125;); return;&#125;","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/categories/Markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]}]}